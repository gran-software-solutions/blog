---
title: Concurrency in REST APIs
authors: dodalovicgran
tags: [REST API]
---

![Example banner](./img.png)

In this article, we will show you how to design and implement a REST API that can handle concurrent requests when updating the same resource.

We also provided <u>[a sample code](#sample-code)</u> which you can use to implement the described solution.

<!--truncate-->

## What's the problem to solve?

The issue we want to tackle can also be described as "lost updates". When do such updates happen? When the same resources are attempted to be updated by multiple clients at the same time.
What happens in such cases, if you don't have any special handling? **The last update wins**.

Depending on the use case, this may or may not be a problem.

In case you want more predictable behavior, so that the end state is not determined by "pure luck", follow the rest of the article, where we describe how you can implement a solution based on ETags[^1].

## What are ETags?

ETag can be described as a fingerprint of a resource. It's a unique identifier that is generated based on the content of the resource. If the content changes, the ETag changes as well.
ETag is used for caching purposes, as well as for concurrency control, which is our use case.

### Weak vs Strong ETags

ETags can be either **strong** or **weak**. Strong ETags guarantee byte-for-byte equality. They are more expensive to generate. Weak ETags only guarantee that the content is semantically equal.

For our use case, we will use weak ETags.

The format of a weak ETag is `W/"ETAG_HERE"`. The `W/` prefix indicates that the ETag is weak.

<details>
<summary><code>ETag</code> vs <code>Last-Modified</code></summary>

`Last-Modified` header is another way to handle caching/concurrency. How does it work? When we fetch a resource from the server, we get a `Last-Modified` header in the response. This header contains the **date
and time when the resource was last modified**. When we want to update the resource, we send the `If-Unmodified-Since` header[^2] in the request. The server will check if the resource was modified after the date and
time specified in the header. If it was, the update will be rejected with `412 Precondition Failed` response. If it wasn't, the server will proceed with handling the request.

The issue with this approach is its precision. The `Last-Modified` header is only precise to the second. If the resource is updated multiple times in the same second, the `If-Unmodified-Since` header will not be
able to distinguish between the updates.

</details>

## Real-world example

If we have no special handling of concurrent requests, this leads to **"lost updates"** problem. This means that the later request overwrites the changes made by the earlier requests, making them "lost".

Let's demonstrate the problem of lost updates with an example. Let's, for a moment, pretend there's no such thing as Google Docs or similar collaborative editing tools.
Our boss comes to us and says:

> We need a tool that will allow group of people to **work together on a text document**. It needs to be finished in **2 days**.

With all the time in the world, we came up with the following design:

* This **will not be** a real-time collaboration where we can see the changes as they happen
* A user will only be able to update the document if the document is based on the **latest version of the document**

The business was happy with the design proposal, so we started implementing it.

### The user experience

After we finished the implementation, we tested it, by inviting 2 of our colleagues (Jeannie and Frank) to test it out.
The following is a timeline of Jeanie and Frank's actions and the results:

![Action sequence](./action-sequence.png)

Our boss was happy with the results!

## Design & Implementation

To be able to achieve such user experience, we came up with the following API design:

* We will use **weak ETags** to handle concurrency
* We will need 2 API operations, one to **save** and one to **get** a document

### Saving a document

We designed saving a document so that it will use an idempotent `PUT` HTTP method. This method will be used to create a new document, as well as to update an existing one.
Clients are allowed to set the `documentId`.

The following is a sequence diagram of how the API operation was implemented:

```mermaid
flowchart TD
    A([Start]) --> B{Request body present?}
    B -- Yes --> C[Get documentID path param]
    C --> D[Get document from DB by documentID]
    D --> E{Document exists?}
    E -- No --> F[Save new document]
    F --> G([HTTP 204])
    E -- Yes --> H[Get If-Match header value from request]
    H --> I{Value missing?}
    I -- Yes --> J([HTTP 428 - Precondition required])
    I -- No --> K{Request ETag == document Etag?}
    K -- Yes --> L[Update document]
    L --> G
    K -- No -->  N([HTTP 412 -Precondition failed])
    B -- No ----> O([HTTP 400 - Bad request])
```

:::tip
Requirements for this sequence are described in the [RFC 7232](https://www.rfc-editor.org/rfc/rfc7232#section-5)
:::

### Getting a document

Getting a document is far simpler. Using standard `GET` HTTP method, we will return the document with the provided `documentId`. If there's no document with the provided `documentId`,
we will return `404 Not Found`.

The following is a sequence diagram of how the API operation was implemented:

```mermaid
flowchart TD
    A([Start]) --> B[Resolve document by provided documentID]
    B --> C{Document exists?}
    C -- No --> D([HTTP 404])
    C -- Yes --> E([HTTP 200])
```

## Sample code

On our <u>[GitHub](https://github.com/gran-software-solutions/code-samples/tree/main/concurrency-in-rest-apis)</u> we've published a sample project that implements the described API.
The sample code is written in <u>[Kotlin](https://kotlinlang.org/)</u> using <u>[Vert.x](https://vertx.io/)</u> toolkit. It requires having <u>[JDK 11](https://adoptopenjdk.net/)</u> or newer installed

Here's how you can run it:

* Clone the repository
  ```shell
  git clone git@github.com:gran-software-solutions/code-samples.git
  ```
* Run the following command in the root of the project:
  ```shell
  cd concurrency-in-rest-apis
  ./gradlew run
  ```
* This will start the server on port `8888`
* Open another shell to run the commands to test the API
* Create a new document with id `7051d73e-9e82-44ca-a0d9-eb8af23b9cf6`
   ```shell
   curl -i -X PUT \
      -H "Content-Type: text/plain" \
      -d 'some content' \
      http://localhost:8888/documents/7051d73e-9e82-44ca-a0d9-eb8af23b9cf6
   ```
* Get the document with id `7051d73e-9e82-44ca-a0d9-eb8af23b9cf6`
  ```shell
  curl -i \
    http://localhost:8888/documents/7051d73e-9e82-44ca-a0d9-eb8af23b9cf6
  ```
* In the response, you will see the `ETag` header. It will look something like this: `ETag: W/"XXXYYYZZZ"`. Copy the value of the header.
* Update the document with id `7051d73e-9e82-44ca-a0d9-eb8af23b9cf6`
  ```shell
  curl -i -X PUT \
    -H "Content-Type: text/plain" \
    -H 'If-Match: W/"XXXYYYZZZ"' \
    -d 'some new content' \
    http://localhost:8888/documents/7051d73e-9e82-44ca-a0d9-eb8af23b9cf6
  ```
* Repeat the previous command. You will see that the API returns `412 Precondition Failed` because the `ETag` header doesn't match the document's ETag.
* Repeat the previous command, this time without the `If-Match` header. You will see that the API returns `428 Precondition Required` because the `If-Match` header is missing.

## What now?

There are some things you can check on your own projects:

* Do you have use-cases where your APIs try to mutate the same resource at the same time? To avoid hard times troubleshooting concurrency issues, think about if ETags or at least `If-Unmodified-Since` headers would be a good fit for your use-case.
* You can leverage ETags even to implement caching. If you have a read-heavy API and resources expensive to compute, ETags can come in handy

[^1]: [ETag](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/ETag)
[^2]: [If-Unmodified-Since](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-Unmodified-Since)